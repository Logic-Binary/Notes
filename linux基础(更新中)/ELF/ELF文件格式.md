<font color="#7f7f7f">本部分内容来源于 ELF 1.2 标准，内容经过一定的修改与整理</font>
## 简介
Elf文件，也就是Linux中的目标文件，主要有以下三种类型
- 可重定位文件，包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在Linux系统中，这种文件的后缀为.o  (我把它理解为中间文件)
- 可执行文件，通常在Linux中执行的程序. （对比win中的.exe文件）
- 共享目标文件，包含代码和数据，这种文件是我们所称的库文件，一般以.so结尾。一般情况下，它有以下两种使用情景（对比win下.dll文件）
	- 链接器可能会处理它和其它可重定位文件以及共享目标文件，生成另一个目标文件。(链接器的主要任务包括符号解析、地址重定向和符号合并等)
	- 动态链接器将它与可执行文件以及其它共享目标组合在一起生成进程镜像

 目标文件由汇编器和链接器创建，是文本程序的二进制形式，可以直接在处理器上运行
## 文件格式

 目标文件即会参与程序链接又会参与程序执行。处于方便性和效率性考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下
 ![[Linux目标文件格式.png]]
 首先，关注一下链接视图
 文件开始处是ELF头部，他给出了整个文件的组织情况。
 如果程序头部表存在的话，它会告诉系统如何创建进程。用于生成进程的目标文件必须具有程序头部表，但是重定位文件不需要这个表。
 节区部分包含在链接视图中要使用的大部分信息：指令，数据，符号表，重定位信息等等。
 节区头部表包含了描述文件节区的信息，每个节区在表中都有一个表项，会给出节区名称，节区大小等信息。用于链接的目标文件必须有节区头部表，其他目标文件则无所谓，可以有，也可以没有。
 链接视图展示
 ![[Linux链接视图.png]]
对于执行视图来说，其主要的不同点在于没有了section，而有了多个segment。其实这里的segment大都是来源于链接视图中的section。
PS:
<font color="#7f7f7f">尽管图中是按照 ELF 头，程序头部表，节区，节区头部表的顺序排列的。但实际上除了 ELF 头部表以外，其它部分都没有严格的的顺序。</font>



## 数据形式
ELF 文件格式支持 8 位/32 位体系结构。当然，这种格式是可以扩展的，也可以支持更小的或者更大位数的处理器架构。因此，目标文件会包含一些控制数据，这部分数据表明了目标文件所使用的架构，这也使得它可以被通用的方式来识别和解释。目标文件中的其它数据采用目的处理器的格式进行编码，与在何种机器上创建没有关系。这里其实想表明的意思目标文件可以进行交叉编译，我们可以在 x86 平台生成 arm 平台的可执行代码。
目标文件中的所有数据结构都遵从“自然”大小和对齐规则。如下

![[Image/Linux文件格式/1.png]]

如果必要，数据结构可以包含显式地补齐来确保 4 字节对象按 4 字节对齐，强制数据结构的大小是 4 的整数倍等等。数据同样适用是对齐的。因此，包含一个 Elf32_Addr 类型成员的结构体会在文件中的 4 字节边界处对齐。

为了具有可移植性，ELF 文件不使用位域。

以下介绍中，我们以32位为主进行介绍

## ELF Header
ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，数据结构如下：

typedef struct {
    unsigned char   [[e_ident]][16];  
	ELF32_Half      [[e_type]];              
    ELF32_Half      [[e_machine]];
    ELF32_Word      [[e_version]];
    <font color="#ffff00">ELF32_Addr</font>      [[e_entry]];
    <font color="#ffff00">ELF32_Off</font>       [[e_phoff]];
    <font color="#ffff00">ELF32_Off</font>       [[e_shoff]];
    ELF32_Word      [[e_flags]];
    ELF32_Half      [[e_ehsize]];
    ELF32_Half      [[e_phentsize]];
    ELF32_Half      [[e_phnum]];
    ELF32_Half      [[e_shentsize]];
    ELF32_Half      [[e_shnum]];
    ELF32_Half      [[e_shstrndx]];
} Elf32_Ehdr;
![[Pasted image 20240404134149.png]]
![[Pasted image 20240404134234.png]]
![[Pasted image 20240404134315.png]]
![[Pasted image 20240404134336.png]]
## Program Header Table
### 概述
Program Header Table 是一个结构体数组，每一个元素的类型是 `Elf32_Phdr`，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 `e_phentsize` 和 `e_phnum` 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。**程序的头部只有对于可执行文件和共享目标文件有意义。

可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。

`Elf32_Phdr` 的数据结构如下

typedef struct {
    ELF32_Word  [[p_type]];   //段类型
    ELF32_Off   [[p_offset]];   //段文件偏移
    ELF32_Addr  [[p_vaddr]]; //段虚拟地址
    ELF32_Addr  [[p_paddr]]; //段物理地址
    ELF32_Word  [[p_filesz]];  //段文件大小
    ELF32_Word  [[p_memsz]]; //段内存大小
    ELF32_Word  [[p_flags]];  //段权限
    ELF32_Word  [[p_align]]; //对齐粒度
} Elf32_Phdr;


### 基地址-Base Address

程序头部的虚拟地址可能并不是程序内存镜像中实际的虚拟地址。通常来说，可执行程序都会包含绝对地址的代码。为了使得程序可以正常执行，段必须在相应的虚拟地址处。另一方面，共享目标文件通常来说包含与地址无关的代码。这可以使得共享目标文件可以被多个进程加载，同时保持程序执行的正确性。尽管系统会为不同的进程选择不同的虚拟地址，但是它仍然保留段的相对地址，**因为地址无关代码使用段之间的相对地址来进行寻址，内存中的虚拟地址之间的差必须与文件中的虚拟地址之间的差相匹配**。内存中任何段的虚拟地址与文件中对应的虚拟地址之间的差值对于任何一个可执行文件或共享对象来说是一个单一常量值。这个差值就是基地址，基地址的一个用途就是在动态链接期间重新定位程序。

可执行文件或者共享目标文件的基地址是在执行过程中由以下三个数值计算的

- 虚拟内存加载地址
- 最大页面大小
- 程序可加载段的最低虚拟地址

要计算基地址，首先要确定可加载段中 p_vaddr 最小的内存虚拟地址，之后把该内存虚拟地址缩小为与之最近的最大页面的整数倍即是基地址。根据要加载到内存中的文件的类型，内存地址可能与 p_vaddr 相同也可能不同。



### 段内容
一个段可能包括一到多个节区，但是这并不会影响程序的加载。尽管如此，我们也必须需要各种各样的数据来使得程序可以执行以及动态链接等等。下面会给出一般情况下的段的内容。对于不同的段来说，它的节的顺序以及所包含的节的个数有所不同。此外，与处理相关的约束可能会改变对应的段的结构。

如下所示，代码段只包含只读的指令以及数据。当然这个例子并没有给出所有的可能的段。

![[Image/Linux文件格式/2.png]]
数据段包含可写的数据以及以及指令，通常来说，包含以下内容

![[3.png]]

程序头部的 PT_DYNAMIC 类型的元素指向指向 .dynamic 节。其中，got 表和 plt 表包含与地址无关的代码相关信息。尽管在这里给出的例子中，plt 节出现在代码段，但是对于不同的处理器来说，可能会有所变动。

.bss 节的类型为 SHT_NOBITS，这表明它在 ELF 文件中不占用空间，但是它却占用可执行文件的内存镜像的空间。通常情况下，没有被初始化的数据在段的尾部，因此，`p_memsz` 才会比 `p_filesz` 大。

注意：

- 不同的段来说可能会有所重合，即不同的段包含相同的节。


## Section Header Table

其实这个数据结构是在 ELF 文件的尾部（ **为什么要放在文件尾部呢？？** ），但是为了讲解方便，这里将这个表放在这里进行讲解。

该结构用于定位 ELF 文件中的每个节区的具体位置。

首先，ELF头中的 `e_shoff` 项给出了从文件开头到节头表位置的字节偏移。`e_shnum` 告诉了我们节头表包含的项数；`e_shentsize` 给出了每一项的字节大小。

其次，节头表是一个数组，每个数组的元素的类型是 `ELF32_Shdr` ，每一个元素都描述了一个节区的概要内容。


### ELF32_Shdr
每个节区头部可以用下面的数据结构进行描述：

typedef struct {
    ELF32_Word      sh_name;
    ELF32_Word      sh_type;
    ELF32_Word      [[sh_flags]];
    ELF32_Addr      sh_addr;
    ELF32_Off       sh_offset;
    ELF32_Word      sh_size;
    ELF32_Word      [[sh_link]];   //同link一张表叙述
    ELF32_Word      sh_info;  //同info一张表叙述
    ELF32_Word      sh_addralign;   //对齐粒度
    ELF32_Word      sh_entsize;      //若存在固定大小表项，该字段反应每个表项大小
} Elf32_Shdr;


每个字段的含义如下

| 成员           | 说明                                                                                                                                     |
| :----------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| sh_name      | 节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。                                        |
| sh_type      | 根据节的内容和语义进行分类，具体的类型下面会介绍。                                                                                                              |
| sh_flags     | 每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。                                                                                                     |
| sh_addr      | 如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。                                                                                   |
| sh_offset    | 给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。                                                             |
| sh_size      | 此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。                                          |
| sh_link      | 此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。                                                                                                          |
| sh_info      | 此成员给出附加信息，其解释依赖于节区类型。                                                                                                                  |
| sh_addralign | 某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword(双字4字节) 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralign =0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 |
| sh_entsize   | 某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为0。                                                                              |

索引为0的节区头，此索引标记的是未定义的节区引用。这一项的信息如下

| 字段名称         | 取值        | 说明    |
| ------------ | --------- | ----- |
| sh_name      | 0         | 无名称   |
| sh_type      | SHT_NULL  | 限制    |
| sh_flags     | 0         | 无标志   |
| sh_addr      | 0         | 无地址   |
| sh_offset    | 0         | 无文件偏移 |
| sh_size      | 0         | 无大小   |
| sh_link      | SHN_UNDEF | 无链接信息 |
| sh_info      | 0         | 无辅助信息 |
| sh_addralign | 0         | 无对齐要求 |
| sh_entsize   | 0         | 无表项   |

###  [[符号表索引值所代表的]]


### 特殊下标

节头表中比较特殊的几个下标如下

| 名称            | 值      | 含义                                                                                                                                  |
| ------------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| SHN_UNDEF     | 0      | 标志未定义的，丢失的，不相关的或者其它没有意义的节引用。例如，与节号SHN_UNDEF相关的“定义"的符号就是一个未定义符号。**注：虽然0号索引被保留用于未定义值，节头表仍然包含索引0的项。也就是说，如果ELF头的e_shnum为6，那么索引应该为0~5。** |
| SHN_LORESERVE | 0xff00 | 保留索引值范围的下界。                                                                                                                         |
| SHN_LOPROC    | 0xff00 | 处理器相关的下界                                                                                                                            |
| SHN_HIPROC    | 0xff1f | 处理器相关的上界                                                                                                                            |
| SHN_ABS       | 0xfff1 | 相关引用的绝对值。例如与节号SHN_ABS相关的符号拥有绝对值，它们不受重定位的影响                                                                                          |
| SHN_COMMON    | 0xfff2 | 这一节区相定义的符号是通用符号，例如FORTRAN COMMON，C语言中未分配的外部变量。                                                                                      |
| SHN_HIRESERVE | 0xffff | 保留索引值范围的上界。                                                                                                                         |

**系统保留在`SHN_LORESERVE`到`SHN_HIRESERVE`之间(包含边界)的索引值，这些值不在节头表中引用。也就是说，节头表不包含保留索引项。没特别理解。**

### 部分节头字段

#### sh_type
节类型目前有下列可选范围，其中 SHT 是**Section Header Table** 的简写。

| 名称                                        | 取值         | 说明                                                                                                                        |
| ----------------------------------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------- |
| SHT_NULL                                  | 0          | 该类型节区是非活动的，这种类型的节头中的其它成员取值无意义。                                                                                            |
| <font color="#ffff00">SHT_PROGBITS</font> | 1          | 该类型节区包含程序定义的信息，它的格式和含义都由程序来决定。                                                                                            |
| <font color="#ffff00">SHT_SYMTAB</font>   | 2          | 该类型节区包含一个符号表（**SYMbol TABle**）。目前目标文件对每种类型的节区都只 能包含一个，不过这个限制将来可能发生变化。 一般，SHT_SYMTAB 节区提供用于链接编辑（指 ld 而言） 的符号，尽管也可用来实现动态链接。 |
| SHT_STRTAB                                | 3          | 该类型节区包含字符串表（ **STRing TABle** ）。                                                                                          |
| <font color="#ffff00">SHT_RELA</font>     | 4          | 该类型节区包含显式指定位数的重定位项（ **RELocation entry with Addends** ），例如，32 位目标文件中的 Elf32_Rela 类型。此外，目标文件可能拥有多个重定位节区。                   |
| SHT_HASH                                  | 5          | 该类型节区包含符号哈希表（ **HASH table** ）。                                                                                           |
| <font color="#ffff00">SHT_DYNAMIC</font>                               | 6          | 该类型节区包含动态链接的信息（ **DYNAMIC linking** ）。                                                                                    |
| SHT_NOTE                                  | 7          | 该类型节区包含以某种方式标记文件的信息（**NOTE**）。                                                                                            |
| SHT_NOBITS                                | 8          | 该类型节区不占用文件的空间，其它方面和SHT_PROGBITS相似。尽管该类型节区不包含任何字节，其对应的节头成员sh_offset 中还是会包含概念性的文件偏移。                                        |
| SHT_REL                                   | 9          | 该类型节区包含重定位表项（**RELocation entry without Addends**），不过并没有指定位数。例如，32位目标文件中的 Elf32_rel 类型。目标文件中可以拥有多个重定位节区。                  |
| SHT_SHLIB                                 | 10         | 该类型此节区被保留，不过其语义尚未被定义。                                                                                                     |
| SHT_DYNSYM                                | 11         | 作为一个完整的符号表，它可能包含很多对动态链接而言不必 要的符号。因此，目标文件也可以包含一个 SHT_DYNSYM 节区，其中保存动态链接符号的一个最小集合，以节省空间。                                    |
| SHT_LOPROC                                | 0X70000000 | 此值指定保留给处理器专用语义的下界（ **LOw PROCessor-specific semantics** ）。                                                                |
| SHT_HIPROC                                | OX7FFFFFFF | 此值指定保留给处理器专用语义的上界（ **HIgh PROCessor-specific semantics** ）。                                                               |
| SHT_LOUSER                                | 0X80000000 | 此值指定保留给应用程序的索引下界。                                                                                                         |
| SHT_HIUSER                                | 0X8FFFFFFF | 此值指定保留给应用程序的索引上界。                                                                                                         |


## Sections
节区包含目标文件中除了 ELF 头部、程序头部表、节区头部表的所有信息。节区满足以下条件

- 每个节区都有对应的节头来描述它。但是反过来，节区头部并不一定会对应着一个节区。
- 每个节区在目标文件中是连续的，但是大小可能为 0。
- 任意两个节区不能重叠，即一个字节不能同时存在于两个节区中。
- 目标文件中可能会有闲置空间（inactive space），各种头和节不一定会覆盖到目标文件中的所有字节，**闲置区域的内容未指定**。

许多在 ELF 文件中的节都是预定义的，它们包含程序和控制信息。这些节被操作系统使用，但是对于不同的操作系统，同一节区可能会有不同的类型以及属性。

可执行文件是由链接器将一些单独的目标文件以及库文件链接起来而得到的。其中，链接器会解析引用（不同文件中的子例程的引用以及数据的引用，调整对象文件中的绝对引用）并且重定位指令。加载与链接过程需要目标文件中的信息，并且会将处理后的信息存储在一些特定的节区中，比如 `.dynamic` 。

每一种操作系统都会支持一组链接模型，但这些模型都大致可以分为两种

| 类型   | 描述                                                                   |
| ---- | -------------------------------------------------------------------- |
| 静态链接 | 静态链接的文件中所使用的库文件或者第三方库都被静态绑定了，其引用已经被解析了。                              |
| 动态链接 | 动态链接的文件中所使用的库文件或者第三方库只是单纯地被链接到可执行文件中。当可执行文件执行时使用到相应函数时，相应的函数地址才会被解析。 |

有一些特殊的节可以支持调试，比如说 .debug 以及 .line 节；支持程序控制的节有 .bss，.data， .data1， .rodata， .rodata1。

|名称|类型|属性|含义|
|:--|:--|:--|:--|
|.comment|SHT_PROGBITS||包含版本控制信息。|
|.debug|SHT_PROGBITS||此节区包含用于符号调试的信息。|
|.dynamic|SHT_DYNAMIC|SHF_ALLOC SHF_WRITE|此节区包含动态链接信息。SHF_WRITE 位设置与否是否被设置取决于具体的处理器。|
|.dynstr|SHT_STRTAB|SHF_ALLOC|此节区包含用于动态链接的字符串，大多数 情况下这些字符串代表了与符号表项相关的名称。|
|.dynsym|SHT_DYNSYM|SHF_ALLOC|此节区包含动态链接符号表。|
|.got|SHT_PROGBITS||此节区包含全局偏移表。|
|.line|SHT_PROGBITS||此节区包含符号调试的行号信息，描述了源程序与机器指令之间的对应关系，其内容是未定义的。|
|.plt|SHT_PROGBITS||此节区包含过程链接表（procedure linkage table）。|
|.relname|SHT_REL||这些节区中包含重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含SHF_ALLOC位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。|
|.relaname|SHT_RELA|||
|.shstrtab|SHT_STRTAB||此节区包含节区名称。|


## 关于节的设想
在编译链接后我试着将节的信息全部置空，程序依旧可以正常运行，这点是否可以利用？






