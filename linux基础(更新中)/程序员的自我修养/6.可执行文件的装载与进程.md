
### 进程是如何建立的
- 创建一个独立的虚拟地址空间
	可执行文件是以segement为单位，操作系统以页为单位，创建控件实际上是创建函数所需要的相应的数据结构，创建虚拟地址空间实际上只要分配一个页目录即可，甚至不用映射关系，这些关系到后面程序发生页错误可以再进行设置。

- 读取可执行文件头，建立映射关系
	上一步映射关系函数是把虚拟地址转换为物理地址，这一步的映射关系是虚拟地址与可执行文件的映射关系

- 将CPU指令寄存器设置为可执行文件的入口，启动运行

### 页错误
   上面的步骤完成之后，可执行文件的指令和数据都没有被装入到内存中，操作系统只是通过可以执行文件头部信息建立起可执行文件和进程虚拟内存之间的关系。
   假设在上面的例子中，程序入口地址为0x08048000,刚好是.text段的起始地址。当CPU开始打算执行这个地址的指令时，发现0x8048000-0x8049000是个空页，便触发页异常。CPU将控制权交给操作系统，操作系统分配物理页，建立虚拟页与物理页的映射关系，重新执行。

当我们站在操作系统装载可执行文件的角度上去看，可以为发现它并不关心可执行文件各个段所包含的实际内容，只关心段权限(可读，可写，可执行)。ELF中，基本是三种权限组合
- 以代码段为代表的权限为可读可执行的段
- 以数据段和BSS段为代表的权限为可读可写的段
- 以只读数据段为代表的权限为只读的段
于是有了一个很简单的方案：对于相同权限的段，把它们合并到一起当作一个段进行映射。

## 程序头表
typedef struct
{
  Elf64_Word  p_type;     /* Segment type */
  Elf64_Word  p_flags;    /* Segment flags */
  Elf64_Off p_offset;   /* Segment file offset */
  Elf64_Addr  p_vaddr;    /* Segment virtual address */
  Elf64_Addr  p_paddr;    /* Segment physical address */
  Elf64_Xword p_filesz;   /* Segment size in file */
  Elf64_Xword p_memsz;    /* Segment size in memory */
  Elf64_Xword p_align;    /* Segment alignment */
} Elf64_Phdr;
![](./图片/Pasted%20image%2020240418175344.png)


对于“LOAD”类型的段来说，p_memsz的值不可以小于p_filesz，否则就是不符合常理的。如果p_memsz大于p_filesz，表示段在内存中所分配的空间大小超过文件中实际的大小，这部分“多余”的部分全部填充为0，这样做我们在构造ELF可执行文件时不需要再额外设立BSS的段了，可以把数据段的p_memsz扩大，那些额外的部分就是BSS。

## 堆和栈
在操作系统里，VMA除了被用来映射可执行文件中的各个“Segment”外，他还有其它的作用，操作系统通过使用VMA来对进程的地址空间进行管理。我们知道进程在执行的还需要栈，堆等空间，事实上它们在进程的虚拟空间中的表现也是以VMA的形式存在的，一个进程基本上可以分为以下几种VMA区域
- 代码VMA，只读可执行；有映像文件
- 数据VMA，可读写可执行；有映像文件(ps:不知道书中写错了还是因为年代久远，现在的数据段应该是不可执行了)
- 堆VMA，可读写，可执行；无映像文件，可向上拓展
- 栈VMA，可读写，不可知性，可向下拓展

当我们讨论进程虚拟空间的“Segment”的时候，基本上是指上面几种VMA

## 段地址对齐
对于inter80x86系列处理器来说，默认页大小是4kb(4096字节)。我们要建立虚拟地址与物理地址之间的关系，这段空间在物理内存和进程虚拟内存的起始地址必须是4096的整数倍，他应该尽量优化自己的地址，节省空间。我们来看一个例子，假设我们有三个段需要装载SEG0，SEG1，SEG2
![[Pasted image 20240418220610.png]]每个段的长度都不是页长度的整数倍，一种最简单的办法就是每个段分开映射，对于长度不足一个页的则占一个页。但这样会浪费内存空间，unix系统采用了一种很巧妙的办法，对于SEG0和SEG1接壤部分的那个物理页，系统将它们映射两份到虚拟地址空间，一份为SEG0，另一份为SEG1，其他页正常映射。ps:unix将ELF的文件头也看做是系统的一个段，将其映射到进程的地址空间。(这一段在书中没有理解其含义)
![](./图片/Pasted%20image%2020240418221709.png)
![[Pasted image 20240418221709.png]]

## 进程栈初始化
进程刚开始启动的时候，需要知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数，很常见的一种做法就是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间栈中(也就是VMA中的Stack VMA)。让我们来看看LINUX的进程初始化后栈的结构，我们假设系统中有两个环境变量
HOME = /home/user
PATH = /usr/bin
比如我们运行该程序的命令行是：
prog 123
假设堆栈底部地址为0xBF802000，那么进程初始化后的堆栈就如下图
![](./图片/Pasted%20image%2020240418222453.png)


栈顶寄存器ESP指向的位置是初始化以后堆栈的顶部，最前面的4个字节表示命令行参数数量，我们的例子是两个参数，即“prog”，“123”，紧接着就是分布指向这两个参数字符串的指针，后面跟了一个0，接着是两个指向环境变量字符串的指针，它们分别指向字符串“HOME = /home/user”和“PATH = /usr/bin”；最后一个0

进程在启动后，程序的库部分会把堆栈里的初始化信息中的参数信息传递给main()函数，也就是我们熟知的main()函数的两个argc和argv两个参数。

## 内核装载ELF过程
当我们在终端输入某个命令执行ELF程序时，Linux系统是怎样装载这个ELF文件并且执行它的呢
在用户层，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，等到用户输入。execve()系统调用定义在unistd.h，原型如下
extern int execve (const char *__path, char *const __argv[], char *const __envp[])
 参数1：执行的程序名
 参数2：执行参数
 参数3：环境变量

在进入execve()系统调用之后，Linux内核就开始进行真正的装载工作。在内核中，execve()系统调用相应的入口是sys_execve(),它进行一些参数检查复制后，调用do_execve()。这个函数如果找到被执行的文件，首先读取前128字节，(为了未来的某一天可能支持PE/java/脚本等)调用search_binary_handle()去搜索匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handle()确定文件格式，调用相应装载处理过程。ELF可执行文件装载处理过程叫load_elf_binary();
a.out可执行文件的装载处理过程叫load_aout_binary();装载可执行脚本程序的处理过程叫load_script()。这里我们只关心ELF可执行文件的装载，主要步骤是：
1. 检查ELF可执行文件格式的有效性，比如魔数，程序头表中段的数量
2. 寻找动态链接的".interp"段，设置动态链接器路径
3. 根据ELF可执行文件的程序头表描述，对ELF文件进行映射
4. 初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该时DT_FINI的地址
5. 将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的连接方式，对于静态链接的ELF可执行文件，程序入口点就是ELF文件的文件头中的e_entry所指的地址，对于动态链接的ELF可执行文件，程序入口点时动态链接器。

当load_elf_binary()执行完毕，返回值do_execve(),再返回至sys_execve()时，第五步已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了。

