
### 进程是如何建立的
- 创建一个独立的虚拟地址空间
	可执行文件是以segement为单位，操作系统以页为单位，创建控件实际上是创建函数所需要的相应的数据结构，创建虚拟地址空间实际上只要分配一个页目录即可，甚至不用映射关系，这些关系到后面程序发生页错误可以再进行设置。

- 读取可执行文件头，建立映射关系
	上一步映射关系函数是把虚拟地址转换为物理地址，这一步的映射关系是虚拟地址与可执行文件的映射关系

- 将CPU指令寄存器设置为可执行文件的入口，启动运行

### 页错误
   上面的步骤完成之后，可执行文件的指令和数据都没有被装入到内存中，操作系统只是通过可以执行文件头部信息建立起可执行文件和进程虚拟内存之间的关系。
   假设在上面的例子中，程序入口地址为0x08048000,刚好是.text段的起始地址。当CPU开始打算执行这个地址的指令时，发现0x8048000-0x8049000是个空页，便触发页异常。CPU将控制权交给操作系统，操作系统分配物理页，建立虚拟页与物理页的映射关系，重新执行。

当我们站在操作系统装载可执行文件的角度上去看，可以为发现它并不关心可执行文件各个段所包含的实际内容，只关心段权限(可读，可写，可执行)。ELF中，基本是三种权限组合
- 以代码段为代表的权限为可读可执行的段
- 以数据段和BSS段为代表的权限为可读可写的段
- 以只读数据段为代表的权限为只读的段
于是有了一个很简单的方案：对于相同权限的段，把它们合并到一起当作一个段进行映射。

## 程序头表
typedef struct
{
  Elf64_Word  p_type;     /* Segment type */
  Elf64_Word  p_flags;    /* Segment flags */
  Elf64_Off p_offset;   /* Segment file offset */
  Elf64_Addr  p_vaddr;    /* Segment virtual address */
  Elf64_Addr  p_paddr;    /* Segment physical address */
  Elf64_Xword p_filesz;   /* Segment size in file */
  Elf64_Xword p_memsz;    /* Segment size in memory */
  Elf64_Xword p_align;    /* Segment alignment */
} Elf64_Phdr;

![[Pasted image 20240418175344.png]]

对于“LOAD”类型的段来说，p_memsz的值不可以小于p_filesz，否则就是不符合常理的。如果p_memsz大于p_filesz，表示段在内存中所分配的空间大小超过文件中实际的大小，这部分“多余”的部分全部填充为0，这样做我们在构造ELF可执行文件时不需要再额外设立BSS的段了，可以把数据段的p_memsz扩大，那些额外的部分就是BSS。

## 堆和栈
在操作系统里，VMA除了被用来映射可执行文件中的各个“Segment”外，他还有其它的作用，操作系统通过使用VMA来对进程的地址空间进行管理。我们知道进程在执行的还需要栈，堆等空间，事实上它们在进程的虚拟空间中的表现也是以VMA的形式存在的，一个进程基本上可以分为以下几种VMA区域