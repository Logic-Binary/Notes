## 消除C++的重复代码
例如模板，在一个编译单元被实例化，它并不知道是否在另一个编译单元也被实例化了。所以，当它在多个编译单元被实例化成相同类型的时候，会产生相同的重复代码，当然，可以将这些全部保留，但会出现这些问题
- 空间浪费
- 地址容易出错
- 指令缓存命中率降低

一个比较有效的做法就是将每个模板的实力代码单独存放在一个段里，每个段只包含一个模板实例。
比如一个模板函数add<T>( )，某个编译单元以int和float实例了该模板函数，此时我们有了两个模板实例的段.temp.add<int> .temp.add<float>。这样的话，别的编译单元也以int或float类型实例化该模板函数后，也会产生相同的名字，最终链接的时候便可以区分这些相同模板的实例段，然后合并。

但是这样还是会存在一些问题，比如相同名称的段可能拥有不同的内容，这可能是由于不同的编译单元使用了不同的编译器版本或者编译优化选项，导致同一个函数编译出来的实际代码有所不同。这种情况下链接器会随意选择一个副本作为链接输入，然后给你一个警告。

## 全局构造与析构
- .init 该段里保存的是可执行指令，它构成了进程的初始化代码。在main函数之前调用
- .fini 该段里保存着进程终止的代码。main函数正常退出时，Glibc会安排执行这个段中的代码。
