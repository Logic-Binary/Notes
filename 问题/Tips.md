<font color="#f79646">### 变量存放位置(不同编译器可能不同)</font>
```
static int x1 = 0
static int x2 = 1;
```
 x1 存放在 .bss中 
 x2 存放在.data中
 x1 被认为是未初始化的，被优化节省磁盘空间


### .plt / .got / .plt.got区别
.plt节
- 包含了对于动态链接的函数调用的代码
- 节中条目通常由延迟绑定的指令组成，用于在第一次调用函数时解析函数地址
- 每个函数调用指令都会跳转到.plt节中对应条目，以触发动态链接器对函数地址的解析和重定位

.got节
- 包含全局变量和静态函数的全局偏移地址
- 在程序加载时，.got 节中的条目会被动态链接器填充为实际的全局变量或静态函数地址
- 通过 .got 节可以实现全局变量和静态函数的全局地址访问

.plt.got
- 包含了.plt 节中每个函数调用指令的全局偏移地址。
- .plt.got 节中的条目实际上是.plt节中相应条目的地址
- 程序加载时，.plt.got节中的条目会被动态链接器填充为实际函数地址

总而言之，.plt.got 包含的是需要延迟绑定的函数地址，而 .got 包含的是全局变量和静态函数的地址。.plt则是存放跳转到这两个节中代码

<font color="#f79646">### .rel与.got的区别</font>
- `.rel` 节存储了链接器在链接过程中需要修改的符号引用的位置和方式；
- `.got` 节存储了全局变量和函数的地址引用，在程序运行时用于实现动态链接。

### Segment与Section
自学习ELF之初，我便难以区分这两个单子，在不同的文章文献中它们似乎对两个词没有严格区分。随着接触之深入，我发现，从链接的角度看，ELF是按Section存储的，事实也是如此；从装载的角度看，ELF文件又可以按照Segment划分。
“Segment” 的概念实际上是从装载的角度重新划分了ELF各个段，


### 装载前后的got表

在程序装载前，GOT 表中存储的是重定位入口的符号地址的槽位，这些槽位将在程序装载后被动态链接器填充。因为在装载前，还无法确定动态链接库中的函数或变量的确切地址，所以 GOT 表中的地址是未知的，通常是一个特殊的占位符或空地址
![[Pasted image 20240422105708.png]]

这是装载后的got表
当程序被装载到内存并开始执行时，动态链接器会根据需要将动态链接库中的函数或变量的地址填充到 GOT 表中。这个过程通常称为重定位，动态链接器会根据共享库的加载地址和函数/变量的偏移量来计算正确的地址，并将其填充到 GOT 表中。这样，程序就可以通过 GOT 表来访问共享库中的函数或变量了。
![[Pasted image 20240422105904.png]]